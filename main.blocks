<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="{/N(Dn(2iD/}UnZd+dK(" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id=":JsZAIpZTPdO[O}9g[_a" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    T0 = 0b000000000001," line2="    T1 = 0b000000000010," line3="    T2 = 0b000000000100," line4="    T3 = 0b000000001000," line5="    T4 = 0b000000010000," line6="    T5 = 0b000000100000," line7="    T6 = 0b000001000000," line8="    T7 = 0b000010000000," line9="    T8 = 0b000100000000," line10="    T9 = 0b001000000000," line11="    T10 = 0b010000000000," line12="    T11 = 0b100000000000" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="HLzy~eSxMklVT=RD[/4p" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    const MPR121_ADDRESS = 0x5A" line3="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line4="" line5="    interface TouchController {" line6="        lastTouchStatus: number" line7="        lastEventValue: number" line8="    }" line9="" line10="    let touchController: TouchController" line11="" line12="    interface PresenceDetector {" line13="        lastPresenceDetection: boolean" line14="    }" line15="" line16="    let presenceDetector: PresenceDetector" line17="" line18="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line19="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line20="    const PRESENCE_DETECTED_ID = 2147" line21="" line22="    /**" line23="     * Initialize the touch controller." line24="     */" line25="" line26="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line27="    //% weight=70" line28="    function initTouchController(): void {" line29="" line30="        if (!!touchController) {" line31="            return" line32="        }" line33="" line34="        touchController = {" line35="            lastTouchStatus: 0," line36="            lastEventValue: 0," line37="        }" line38="" line39="        const addr = MPR121_ADDRESS" line40="        mpr121.reset(addr)" line41="" line42="        // Stop capture" line43="        mpr121.stop(addr)" line44="" line45="        // Input filter for rising state" line46="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line47="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line48="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line49="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line50="" line51="        // Input filter for falling state" line52="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line53="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line54="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line55="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line56="" line57="        // Input filter for touched state" line58="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line59="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line60="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line61="" line62="        // Unused proximity sensor filter" line63="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line64="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line65="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line66="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line67="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line68="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line69="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line70="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line71="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line72="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line73="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line74="" line75="        // Debounce configuration (used primarily for interrupts)" line76="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line77="" line78="        // Electrode clock frequency etc" line79="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line80="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line81="" line82="        // Enable autoconfiguration / calibration" line83="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line84="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line85="" line86="        // Tuning parameters for the autocalibration algorithm" line87="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line88="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line89="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line90="" line91="        // Default sensitivity thresholds" line92="        mpr121.configureThresholds(addr, 60, 20)" line93="" line94="        // Restart capture" line95="        mpr121.start(" line96="            addr," line97="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line98="            mpr121.Proximity.DISABLED," line99="            mpr121.Touch.ELE_0_TO_11" line100="        )" line101="        control.inBackground(detectAndNotifyTouchEvents)" line102="    }" line103="" line104="    function detectAndNotifyTouchEvents() {" line105="        let previousTouchStatus = 0" line106="        " line107="        while (true) {" line108="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line109="            touchController.lastTouchStatus = touchStatus" line110="" line111="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line112="" line113="                // Raise event when touch starts" line114="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line115="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line116="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line117="                        touchController.lastEventValue = touchSensorBit" line118="                    }" line119="                }" line120="" line121="                // Raise event when touch ends" line122="                if ((touchSensorBit &amp; touchStatus) === 0) {" line123="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line124="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line125="                        touchController.lastEventValue = touchSensorBit" line126="                    }" line127="                }" line128="            }" line129="" line130="            previousTouchStatus = touchStatus" line131="" line132="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line133="        }" line134="    }" line135="" line136="    /**" line137="         * Initialize the presence controller." line138="         */" line139="" line140="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line141="    //% weight=70" line142="    function initPresenceDetector(): void {" line143="" line144="        if (!!presenceDetector) {" line145="            return" line146="        }" line147="" line148="        presenceDetector = {" line149="            lastPresenceDetection: false" line150="        }" line151="" line152="        control.inBackground(detectAndNotifyPresenceDetector)" line153="    }" line154="" line155="    function detectAndNotifyPresenceDetector() {" line156="        let previousPresenceStatus = false;" line157="        " line158="        while (true) {" line159="            if (previousPresenceStatus == false &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 0) {" line160="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line161="                previousPresenceStatus = true;" line162="            }" line163="            if (previousPresenceStatus == true &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 1) {" line164="                previousPresenceStatus = false;" line165="            }" line166="" line167="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line168="        }" line169="" line170="        " line171="    }" line172="" line173="    // Änderungen gemacht :(" line174="    //% blockId=smarthome_presence_detected" line175="    //% block=&quot;wenn Präsenz gemeldet&quot;" line176="    //% weight=65" line177="    export function onPresenceDetected(handler: () =&gt; void) {" line178="        initPresenceDetector();" line179="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line180="            handler();" line181="        })" line182="    }" line183="" line184="    /**" line185="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line186="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line187="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line188="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line189="    */" line190="" line191="    //% blockId=mpr121_touch_on_touch_sensor_down" line192="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line193="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line194="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line195="    //% weight=65" line196="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line197="        initTouchController()" line198="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line199="            setupContextAndNotify(handler)" line200="        })" line201="    }" line202="" line203="    /**" line204="    * Mache etwas, wenn ein spezieller Sensor losgelassen wird." line205="    * Ein Loslass-Ereignis wird am Ende der Berührung ausgeführt." line206="    * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line207="    * @param handler body code der beim Loslassen des Sensors ausgeführt werden soll" line208="    */" line209="" line210="    //% blockId=mpr121_touch_on_touch_sensor_released" line211="    //% block=&quot;wenn Berührungssensor | %sensor | losgelassen&quot;" line212="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line213="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line214="    //% weight=64" line215="    export function onTouchSensorReleased(sensor: TouchSensor, handler: () =&gt; void) {" line216="        initTouchController()" line217="        control.onEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, sensor, () =&gt; {" line218="            setupContextAndNotify(handler)" line219="        })" line220="    }" line221="" line222="    /**" line223="    * Mache etwas, wenn ein beliebiger Sensor berührt wird." line224="    * @param handler body code to run when event is raised" line225="    */" line226="" line227="    // blockId=mpr121_touch_on_touched" line228="    // block=&quot;wenn beliebiger Sensor berührt&quot;" line229="    // weight=60" line230="    export function onAnyTouchSensorTouched(handler: () =&gt; void) {" line231="        initTouchController()" line232="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line233="            setupContextAndNotify(handler)" line234="        })" line235="    }" line236="" line237="    /**" line238="    * Mache etwas, wenn ein beliebiger Sensor losgelassen wird." line239="    * @param handler body code to run when event is raised" line240="    */" line241="" line242="    // blockId=mpr121_touch_on_released" line243="    // block=&quot;wenn beliebiger Sensor losgelassen&quot;" line244="    // weight=59" line245="    export function onAnyTouchSensorReleased(handler: () =&gt; void) {" line246="        initTouchController()" line247="        control.onEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line248="            setupContextAndNotify(handler)" line249="        })" line250="    }" line251="" line252="    function setupContextAndNotify(handler: () =&gt; void) {" line253="        touchController.lastEventValue = control.eventValue()" line254="        handler()" line255="    }" line256="" line257="    /**" line258="     * Gibt die Indexnummer des letzten Berührungsereignisses das empfangen wurde zurück." line259="     * Das kann entweder ein Berühr- oder Loslassereignis sein." line260="     * Dieser Block ist dafür gedacht innerhalb der touch event handler verwendet zu werden." line261="     */" line262="" line263="    // blockId=&quot;mpr121_touch_current_touch_sensor" line264="    // block=&quot;zuletzt berührter Sensor&quot;" line265="    // weight=50" line266="    export function touchSensor(): number {" line267="        initTouchController()" line268="        if (touchController.lastEventValue !== 0) {" line269="            return getSensorIndexFromSensorBitField(touchController.lastEventValue)" line270="        } else {" line271="            return 0" line272="        }" line273="    }" line274="" line275="    function getSensorIndexFromSensorBitField(touchSensorBit: TouchSensor) {" line276="        let bit = TouchSensor.T11" line277="        for (let sensorIndex = 0; sensorIndex &lt;= 11; sensorIndex++) {" line278="            if ((bit &amp; touchSensorBit) !== 0) {" line279="                return 11 - sensorIndex // return first hit" line280="            }                         // Pinnummern an Breakoutboard angepasst." line281="            bit &gt;&gt;= 1" line282="        }" line283="        return 0" line284="    }" line285="" line286="    /**" line287="     * Gibt wahr zurück, wenn ein spezieller Touchsensor gerade berührt wurde. Ansonsten falsch." line288="     * @param sensor the touch sensor to be checked, eg: TouchSensor.T0" line289="     */" line290="" line291="    // blockId=&quot;mpr121_touch_is_touch_sensor_touched&quot; block=&quot;Berührungssensor | %sensor | wird berührt&quot;" line292="    // sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line293="    // sensor.fieldOptions.tooltips=&quot;false&quot;" line294="    // weight=40" line295="    export function isTouched(sensor: TouchSensor): boolean {" line296="        initTouchController()" line297="        return (touchController.lastTouchStatus &amp; sensor) !== 0" line298="    }" line299="" line300="    // Communication module for MPR121 capacitive touch sensor controller" line301="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line302="    export namespace mpr121 {" line303="" line304="        export enum CalibrationLock {" line305="            BaselineTrackingOn = 0b00," line306="            BaselineTrackingOff = 0b01," line307="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line308="            BaselineTrackingAndInitialize = 0b11" line309="        }" line310="" line311="        export enum Proximity {" line312="            DISABLED = 0b00," line313="            ELE0_TO_1 = 0b01," line314="            ELE_0_TO_3 = 0b10," line315="            ELE_0_TO_11 = 0b11" line316="        }" line317="" line318="        export enum Touch {" line319="            DISABLED = 0b0000," line320="            ELE_0 = 0b0001," line321="            ELE_0_TO_1 = 0b0010," line322="            ELE_0_TO_2 = 0b0011," line323="            ELE_0_TO_3 = 0b0100," line324="            ELE_0_TO_4 = 0b0101," line325="            ELE_0_TO_5 = 0b0110," line326="            ELE_0_TO_6 = 0b0111," line327="            ELE_0_TO_7 = 0b1000," line328="            ELE_0_TO_8 = 0b1001," line329="            ELE_0_TO_9 = 0b1010," line330="            ELE_0_TO_10 = 0b1011," line331="            ELE_0_TO_11 = 0b1100" line332="        }" line333="" line334="        export enum Config {" line335="            MHDR = 0x2B," line336="            NHDR = 0x2C," line337="            NCLR = 0x2D," line338="            FDLR = 0x2E," line339="            MHDF = 0x2F," line340="            NHDF = 0x30," line341="            NCLF = 0x31," line342="            FDLF = 0x32," line343="            NHDT = 0x33," line344="            NCLT = 0x34," line345="            FDLT = 0x35," line346="            MHDPROXR = 0x36," line347="            NHDPROXR = 0x37," line348="            NCLPROXR = 0x38," line349="            FDLPROXR = 0x39," line350="            MHDPROXF = 0x3A," line351="            NHDPROXF = 0x3B," line352="            NCLPROXF = 0x3C," line353="            FDLPROXF = 0x3D," line354="            NHDPROXT = 0x3E," line355="            NCLPROXT = 0x3F," line356="            FDLPROXT = 0x40," line357="            E0TTH = 0x41," line358="            E0RTH = 0x42," line359="            E1TTH = 0x43," line360="            E1RTH = 0x44," line361="            E2TTH = 0x45," line362="            E2RTH = 0x46," line363="            E3TTH = 0x47," line364="            E3RTH = 0x48," line365="            E4TTH = 0x49," line366="            E4RTH = 0x4A," line367="            E5TTH = 0x4B," line368="            E5RTH = 0x4C," line369="            E6TTH = 0x4D," line370="            E6RTH = 0x4E," line371="            E7TTH = 0x4F," line372="            E7RTH = 0x50," line373="            E8TTH = 0x51," line374="            E8RTH = 0x52," line375="            E9TTH = 0x53," line376="            E9RTH = 0x54," line377="            E10TTH = 0x55," line378="            E10RTH = 0x56," line379="            E11TTH = 0x57," line380="            E11RTH = 0x58," line381="            E12TTH = 0x59," line382="            E12RTH = 0x5A," line383="            DTR = 0x5B," line384="            AFE1 = 0x5C," line385="            AFE2 = 0x5D," line386="            ECR = 0x5E," line387="            CDC0 = 0x5F," line388="            CDC1 = 0x60," line389="            CDC2 = 0x62," line390="            CDC4 = 0x63," line391="            CDC5 = 0x64," line392="            CDC6 = 0x65," line393="            CDC7 = 0x66," line394="            CDC8 = 0x67," line395="            CDC9 = 0x68," line396="            CDC10 = 0x69," line397="            CDC11 = 0x6A," line398="            CDC12 = 0x6B," line399="            CDT_0_1 = 0x6C," line400="            CDT_2_3 = 0x6D," line401="            CDT_4_5 = 0x6E," line402="            CDT_6_7 = 0x6F," line403="            CDT_8_9 = 0x70," line404="            CDT_10_11 = 0x71," line405="            CDT_12 = 0x72," line406="            GPIO_CTL0 = 0x73," line407="            GPIO_CTL1 = 0x74," line408="            GPIO_DIR = 0x76," line409="            GPIO_EN = 0x77," line410="            GPIO_SET = 0x78," line411="            GPIO_CLR = 0x79," line412="            GPIO_TOG = 0x7A," line413="            AUTO_CONFIG_0 = 0x7B," line414="            AUTO_CONFIG_1 = 0x7C," line415="            AUTO_CONFIG_USL = 0x7D," line416="            AUTO_CONFIG_LSL = 0x7E," line417="            AUTO_CONFIG_TL = 0x7F" line418="        }" line419="" line420="        let commandDataBuffer: Buffer" line421="        let commandBuffer: Buffer" line422="" line423="        function writeCommandData(address: number, command: number, data: number): void {" line424="            if (!commandDataBuffer) {" line425="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line426="            }" line427="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line428="            pins.i2cWriteBuffer(address, commandDataBuffer)" line429="        }" line430="" line431="        function writeCommand(address: number, command: number): void {" line432="            if (!commandBuffer) {" line433="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line434="            }" line435="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line436="            pins.i2cWriteBuffer(address, commandBuffer)" line437="        }" line438="" line439="        export function configure(address: number, register: Config, value: number): void {" line440="            writeCommandData(address, register, value)" line441="        }" line442="" line443="        export function configureThresholds(address: number, touch: number, release: number): void {" line444="            for (let i = 0; i &lt; 12; i++) {" line445="                configure(address, Config.E0TTH + i * 2, touch)" line446="                configure(address, Config.E0RTH + i * 2, release)" line447="            }" line448="        }" line449="" line450="        export function reset(address: number): void {" line451="            writeCommandData(address, 0x80, 0x63)" line452="            basic.pause(30)" line453="        }" line454="" line455="        export function stop(address: number): void {" line456="            writeCommandData(address, Config.ECR, 0x0)" line457="        }" line458="" line459="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line460="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line461="        }" line462="" line463="        export function readTouchStatus(address: number): number {" line464="            writeCommand(address, 0x0)" line465="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line466="        }" line467="    }" line468="}" numlines="469"></mutation><next><block type="device_show_leds" id="vsp8:6SUWDNEL^1%6^Mn"><field name="LEDS">`
        . . . . . 
        . . . . . 
        . . # . . 
        . . . . . 
        . . . . .
        `</field></block></next></block></next></block></statement></block><block type="device_forever" id="I90*Fu!?4s?-R=kB_oFT" x="644" y="18167"></block><block type="device_button_selected_event" id="xk^bCe;J]BRa1C{E4P#f" x="560" y="19227"><field name="NAME">Button.A</field><value name="eventType"><shadow type="control_button_event_click" id=".#EI;#Y-7W_Fn*S)g@VN"></shadow></value><statement name="HANDLER"><block type="basic_show_icon" id="D}ceX}p:kuh)Zmw*{oLG"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.No</field></block></statement></block><block type="device_pin_custom_event" id="B4M,Bx5;mep2iQY+DF0}" x="366" y="19407"><field name="name">TouchPin.P1</field><value name="eventType"><shadow type="control_button_event_down" id="zj7b_)$SRbt%tSv.*7Wg"></shadow></value><statement name="HANDLER"><block type="device_show_leds" id="k3ibl`AzMxe}3EfTcJ[J"><field name="LEDS">`
        . . . . . 
        . . . . . 
        # # # . . 
        . . . . . 
        . . . . .
        `</field></block></statement></block><block type="smarthome_presence_detected" id="MCyTgL%s]A~vO|EJ/rlB" x="165" y="19913"><statement name="HANDLER"><block type="basic_show_icon" id="#h2(0RZbMzaBd9pJ.aVM"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.Butterfly</field><next><block type="device_play_note" id="+?VZPZ|2_d{t@o7}V;|@"><value name="note"><shadow type="device_note" id="$SQK}BwD0nKEg0685~Pt"><field name="name">262</field></shadow></value><value name="duration"><shadow type="device_beat" id="{s27(#qA27Mk4PM;KM|K"><field name="fraction">BeatFraction.Whole</field></shadow></value></block></next></block></statement></block></xml>