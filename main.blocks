<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="R1Lo[@o4H(86lfyyg^IU" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="%_BpXCLet~]xL;8?bw}$" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    S0 = 0b000000000001," line2="    S1 = 0b000000000010," line3="    S2 = 0b000000000100," line4="    S3 = 0b000000001000," line5="    S4 = 0b000000010000," line6="    S5 = 0b000000100000," line7="    S6 = 0b000001000000," line8="    S7 = 0b000010000000," line9="    S8 = 0b000100000000," line10="    S9 = 0b001000000000," line11="    // T10 = 0b010000000000, //not used" line12="    // T11 = 0b100000000000. //not used" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="qO+1{nB!?[AJ:#H][hp1" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    /**" line3="     * Code für die Touch Schalter" line4="     * based on https://github.com/mkleinsb/pxt-mpr121 by Michael Klein" line5="     * mpr 121 touch blocks based on touch.ts 0.17.5" line6="     * Auf Basis von https://github.com/1010Technologies/pxt-makerbit" line7="     * Copyright (c) 2018 Roger Wagner, Philipp Henkel &amp; Michael Klein" line8="     * MIT License" line9="     */" line10="" line11="    const MPR121_ADDRESS = 0x5A" line12="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line13="" line14="    interface TouchController {" line15="        lastTouchStatus: number" line16="        lastEventValue: number" line17="    }" line18="" line19="    let touchController: TouchController" line20="" line21="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line22="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line23="    " line24="" line25="    /**" line26="     * Initialize the touch controller." line27="     */" line28="" line29="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line30="    //% weight=70" line31="    function initTouchController(): void {" line32="" line33="        if (!!touchController) {" line34="            return" line35="        }" line36="" line37="        touchController = {" line38="            lastTouchStatus: 0," line39="            lastEventValue: 0," line40="        }" line41="" line42="        const addr = MPR121_ADDRESS" line43="        mpr121.reset(addr)" line44="" line45="        // Stop capture" line46="        mpr121.stop(addr)" line47="" line48="        // Input filter for rising state" line49="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line50="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line51="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line52="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line53="" line54="        // Input filter for falling state" line55="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line56="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line57="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line58="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line59="" line60="        // Input filter for touched state" line61="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line62="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line63="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line64="" line65="        // Unused proximity sensor filter" line66="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line67="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line68="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line69="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line70="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line71="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line72="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line73="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line74="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line75="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line76="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line77="" line78="        // Debounce configuration (used primarily for interrupts)" line79="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line80="" line81="        // Electrode clock frequency etc" line82="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line83="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line84="" line85="        // Enable autoconfiguration / calibration" line86="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line87="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line88="" line89="        // Tuning parameters for the autocalibration algorithm" line90="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line91="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line92="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line93="" line94="        // Default sensitivity thresholds" line95="        mpr121.configureThresholds(addr, 60, 20)" line96="" line97="        // Restart capture" line98="        mpr121.start(" line99="            addr," line100="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line101="            mpr121.Proximity.DISABLED," line102="            mpr121.Touch.ELE_0_TO_11" line103="        )" line104="        control.inBackground(detectAndNotifyTouchEvents)" line105="    }" line106="" line107="    function detectAndNotifyTouchEvents() {" line108="        let previousTouchStatus = 0" line109="        " line110="        while (true) {" line111="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line112="            touchController.lastTouchStatus = touchStatus" line113="" line114="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line115="" line116="                // Raise event when touch starts" line117="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line118="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line119="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line120="                        touchController.lastEventValue = touchSensorBit" line121="                    }" line122="                }" line123="" line124="                // Raise event when touch ends" line125="                if ((touchSensorBit &amp; touchStatus) === 0) {" line126="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line127="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line128="                        touchController.lastEventValue = touchSensorBit" line129="                    }" line130="                }" line131="            }" line132="" line133="            previousTouchStatus = touchStatus" line134="" line135="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line136="        }" line137="    }" line138="" line139="    /**" line140="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line141="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line142="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line143="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line144="    */" line145="" line146="    //% blockId=mpr121_touch_on_touch_sensor_down" line147="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line148="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line149="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line150="    //% weight=65" line151="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line152="        initTouchController()" line153="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line154="            setupContextAndNotify(handler)" line155="        })" line156="    }" line157=" " line158="    function setupContextAndNotify(handler: () =&gt; void) {" line159="        touchController.lastEventValue = control.eventValue()" line160="        handler()" line161="    }" line162="" line163="    // Communication module for MPR121 capacitive touch sensor controller" line164="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line165="    export namespace mpr121 {" line166="" line167="        export enum CalibrationLock {" line168="            BaselineTrackingOn = 0b00," line169="            BaselineTrackingOff = 0b01," line170="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line171="            BaselineTrackingAndInitialize = 0b11" line172="        }" line173="" line174="        export enum Proximity {" line175="            DISABLED = 0b00," line176="            ELE0_TO_1 = 0b01," line177="            ELE_0_TO_3 = 0b10," line178="            ELE_0_TO_11 = 0b11" line179="        }" line180="" line181="        export enum Touch {" line182="            DISABLED = 0b0000," line183="            ELE_0 = 0b0001," line184="            ELE_0_TO_1 = 0b0010," line185="            ELE_0_TO_2 = 0b0011," line186="            ELE_0_TO_3 = 0b0100," line187="            ELE_0_TO_4 = 0b0101," line188="            ELE_0_TO_5 = 0b0110," line189="            ELE_0_TO_6 = 0b0111," line190="            ELE_0_TO_7 = 0b1000," line191="            ELE_0_TO_8 = 0b1001," line192="            ELE_0_TO_9 = 0b1010," line193="            ELE_0_TO_10 = 0b1011," line194="            ELE_0_TO_11 = 0b1100" line195="        }" line196="" line197="        export enum Config {" line198="            MHDR = 0x2B," line199="            NHDR = 0x2C," line200="            NCLR = 0x2D," line201="            FDLR = 0x2E," line202="            MHDF = 0x2F," line203="            NHDF = 0x30," line204="            NCLF = 0x31," line205="            FDLF = 0x32," line206="            NHDT = 0x33," line207="            NCLT = 0x34," line208="            FDLT = 0x35," line209="            MHDPROXR = 0x36," line210="            NHDPROXR = 0x37," line211="            NCLPROXR = 0x38," line212="            FDLPROXR = 0x39," line213="            MHDPROXF = 0x3A," line214="            NHDPROXF = 0x3B," line215="            NCLPROXF = 0x3C," line216="            FDLPROXF = 0x3D," line217="            NHDPROXT = 0x3E," line218="            NCLPROXT = 0x3F," line219="            FDLPROXT = 0x40," line220="            E0TTH = 0x41," line221="            E0RTH = 0x42," line222="            E1TTH = 0x43," line223="            E1RTH = 0x44," line224="            E2TTH = 0x45," line225="            E2RTH = 0x46," line226="            E3TTH = 0x47," line227="            E3RTH = 0x48," line228="            E4TTH = 0x49," line229="            E4RTH = 0x4A," line230="            E5TTH = 0x4B," line231="            E5RTH = 0x4C," line232="            E6TTH = 0x4D," line233="            E6RTH = 0x4E," line234="            E7TTH = 0x4F," line235="            E7RTH = 0x50," line236="            E8TTH = 0x51," line237="            E8RTH = 0x52," line238="            E9TTH = 0x53," line239="            E9RTH = 0x54," line240="            E10TTH = 0x55," line241="            E10RTH = 0x56," line242="            E11TTH = 0x57," line243="            E11RTH = 0x58," line244="            E12TTH = 0x59," line245="            E12RTH = 0x5A," line246="            DTR = 0x5B," line247="            AFE1 = 0x5C," line248="            AFE2 = 0x5D," line249="            ECR = 0x5E," line250="            CDC0 = 0x5F," line251="            CDC1 = 0x60," line252="            CDC2 = 0x62," line253="            CDC4 = 0x63," line254="            CDC5 = 0x64," line255="            CDC6 = 0x65," line256="            CDC7 = 0x66," line257="            CDC8 = 0x67," line258="            CDC9 = 0x68," line259="            CDC10 = 0x69," line260="            CDC11 = 0x6A," line261="            CDC12 = 0x6B," line262="            CDT_0_1 = 0x6C," line263="            CDT_2_3 = 0x6D," line264="            CDT_4_5 = 0x6E," line265="            CDT_6_7 = 0x6F," line266="            CDT_8_9 = 0x70," line267="            CDT_10_11 = 0x71," line268="            CDT_12 = 0x72," line269="            GPIO_CTL0 = 0x73," line270="            GPIO_CTL1 = 0x74," line271="            GPIO_DIR = 0x76," line272="            GPIO_EN = 0x77," line273="            GPIO_SET = 0x78," line274="            GPIO_CLR = 0x79," line275="            GPIO_TOG = 0x7A," line276="            AUTO_CONFIG_0 = 0x7B," line277="            AUTO_CONFIG_1 = 0x7C," line278="            AUTO_CONFIG_USL = 0x7D," line279="            AUTO_CONFIG_LSL = 0x7E," line280="            AUTO_CONFIG_TL = 0x7F" line281="        }" line282="" line283="        let commandDataBuffer: Buffer" line284="        let commandBuffer: Buffer" line285="" line286="        function writeCommandData(address: number, command: number, data: number): void {" line287="            if (!commandDataBuffer) {" line288="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line289="            }" line290="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line291="            pins.i2cWriteBuffer(address, commandDataBuffer)" line292="        }" line293="" line294="        function writeCommand(address: number, command: number): void {" line295="            if (!commandBuffer) {" line296="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line297="            }" line298="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line299="            pins.i2cWriteBuffer(address, commandBuffer)" line300="        }" line301="" line302="        export function configure(address: number, register: Config, value: number): void {" line303="            writeCommandData(address, register, value)" line304="        }" line305="" line306="        export function configureThresholds(address: number, touch: number, release: number): void {" line307="            for (let i = 0; i &lt; 12; i++) {" line308="                configure(address, Config.E0TTH + i * 2, touch)" line309="                configure(address, Config.E0RTH + i * 2, release)" line310="            }" line311="        }" line312="" line313="        export function reset(address: number): void {" line314="            writeCommandData(address, 0x80, 0x63)" line315="            basic.pause(30)" line316="        }" line317="" line318="        export function stop(address: number): void {" line319="            writeCommandData(address, Config.ECR, 0x0)" line320="        }" line321="" line322="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line323="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line324="        }" line325="" line326="        export function readTouchStatus(address: number): number {" line327="            writeCommand(address, 0x0)" line328="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line329="        }" line330="    }" line331="" line332="    /**" line333="     * Code for the presence controller." line334="     * by Moritz Metelmann" line335="     */" line336="" line337="    interface PresenceDetector {" line338="        lastPresenceDetection: boolean" line339="    }" line340="" line341="    let presenceDetector: PresenceDetector" line342="    const PRESENCE_DETECTED_ID = 2147" line343="" line344="    /**" line345="     * Initialize the presence controller." line346="     */" line347="" line348="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line349="    //% weight=70" line350="    function initPresenceDetector(): void {" line351="" line352="        if (!!presenceDetector) {" line353="            return" line354="        }" line355="" line356="        presenceDetector = {" line357="            lastPresenceDetection: false" line358="        }" line359="" line360="        control.inBackground(detectAndNotifyPresenceDetector)" line361="    }" line362="" line363="    function detectAndNotifyPresenceDetector() {" line364="        let previousPresenceStatus = false;" line365="" line366="        while (true) {" line367="            if (previousPresenceStatus == false &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 0) {" line368="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line369="                previousPresenceStatus = true;" line370="            }" line371="            if (previousPresenceStatus == true &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 1) {" line372="                previousPresenceStatus = false;" line373="            }" line374="" line375="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line376="        }" line377="" line378="" line379="    }" line380="" line381="    //% blockId=smarthome_presence_detected" line382="    //% block=&quot;wenn Präsenz gemeldet&quot;" line383="    //% weight=65" line384="    export function onPresenceDetected(handler: () =&gt; void) {" line385="        initPresenceDetector();" line386="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line387="            handler();" line388="        })" line389="    }" line390="}" numlines="391"></mutation><next><block type="device_show_leds" id="bofz4S)VASqKs^7/Mcav"><field name="LEDS">`
        . . . . . 
        . . . . . 
        . . # . . 
        . . . . . 
        . . . . .
        `</field></block></next></block></next></block></statement></block><block type="mpr121_touch_on_touch_sensor_down" id=".,p#W/}7)B3-=+.eJFJ," x="280" y="16382"><field name="sensor">TouchSensor.S0</field><statement name="HANDLER"><block type="device_show_leds" id="N=c~a+{[VLup^M.2;uw%"><field name="LEDS">`
        # . . . # 
        . . . . . 
        . . . . . 
        . . . . . 
        # . . . #
        `</field></block></statement></block><block type="input_on_sound" id="6#tt^.dkS(,AIB9x1~jj" x="12" y="16586"><field name="sound">DetectedSound.Loud</field><statement name="HANDLER"><block type="device_show_leds" id="xlyD9-`2=-V.kkMjVI?:"><field name="LEDS">`
        . . . . # 
        . . . . . 
        . . # . . 
        . . . . . 
        # . . . .
        `</field></block></statement></block><block type="device_forever" id="Rs?8Jbk*b*~gLcl;^lz;" x="594" y="18117"></block><block type="device_button_selected_event" id="ph$=F7z7uSaWl)^(eM_l" x="510" y="19177"><field name="NAME">Button.A</field><value name="eventType"><shadow type="control_button_event_click" id="zN!WBS3$4{Pc/_dcWkEv"></shadow></value><statement name="HANDLER"><block type="basic_show_icon" id="gz9`hw$=iz0k[C|/7;E]"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.No</field></block></statement></block><block type="device_pin_custom_event" id="+.aVg860IcN;|Lc1ypmi" x="316" y="19357"><field name="name">TouchPin.P1</field><value name="eventType"><shadow type="control_button_event_down" id="@.Og)YNJg6T$X*0vSS%B"></shadow></value><statement name="HANDLER"><block type="device_show_leds" id=";gEHP7Gi5;@=NXzQVvhN"><field name="LEDS">`
        . . . . . 
        . . . . . 
        # # # . . 
        . . . . . 
        . . . . .
        `</field></block></statement></block><block type="smarthome_presence_detected" id="$r{ZsAo@CX{HvTSZA}QB" x="316" y="19746"><statement name="HANDLER"><block type="basic_show_icon" id="3zun=OsSUk;et@D-e35a"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.Butterfly</field><next><block type="device_play_note" id="mEF0u5VTfaXT~]Py*xQk"><value name="note"><shadow type="device_note" id="VEBg,yF*C,$s=b=xRZzl"><field name="name">262</field></shadow></value><value name="duration"><shadow type="device_beat" id="XI_5A;58-7!]#Gk8#F|Z"><field name="fraction">BeatFraction.Whole</field></shadow></value></block></next></block></statement></block></xml>