<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="=TEjObM$=)KD5T759+B;" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="i5u(#Msv!Np2R=O!kYV{" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum TouchSensor {" line1="    S0 = 0b000000000001," line2="    S1 = 0b000000000010," line3="    S2 = 0b000000000100," line4="    S3 = 0b000000001000," line5="    S4 = 0b000000010000," line6="    S5 = 0b000000100000," line7="    S6 = 0b000001000000," line8="    S7 = 0b000010000000," line9="    S8 = 0b000100000000," line10="    S9 = 0b001000000000," line11="    // T10 = 0b010000000000, //not used" line12="    // T11 = 0b100000000000. //not used" line13="}" numlines="14"></mutation><next><block type="typescript_statement" id="MPW`Q3`QdqZM8~-i*6oF" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace smarthome {" line1="" line2="    const MPR121_ADDRESS = 0x5A" line3="    const TOUCH_STATUS_PAUSE_BETWEEN_READ = 50" line4="" line5="    interface TouchController {" line6="        lastTouchStatus: number" line7="        lastEventValue: number" line8="    }" line9="" line10="    let touchController: TouchController" line11="" line12="    const MPR121_TOUCH_SENSOR_TOUCHED_ID = 2148" line13="    const MPR121_TOUCH_SENSOR_RELEASED_ID = 2149" line14="    " line15="" line16="    /**" line17="     * Initialize the touch controller." line18="     */" line19="" line20="    //% blockId=&quot;mpr121_touch_init&quot; block=&quot;initialisiere touch-Sensor&quot;" line21="    //% weight=70" line22="    function initTouchController(): void {" line23="" line24="        if (!!touchController) {" line25="            return" line26="        }" line27="" line28="        touchController = {" line29="            lastTouchStatus: 0," line30="            lastEventValue: 0," line31="        }" line32="" line33="        const addr = MPR121_ADDRESS" line34="        mpr121.reset(addr)" line35="" line36="        // Stop capture" line37="        mpr121.stop(addr)" line38="" line39="        // Input filter for rising state" line40="        mpr121.configure(addr, mpr121.Config.MHDR, 0x01)" line41="        mpr121.configure(addr, mpr121.Config.NHDR, 0x01)" line42="        mpr121.configure(addr, mpr121.Config.NCLR, 0x10)" line43="        mpr121.configure(addr, mpr121.Config.FDLR, 0x20)" line44="" line45="        // Input filter for falling state" line46="        mpr121.configure(addr, mpr121.Config.MHDF, 0x01)" line47="        mpr121.configure(addr, mpr121.Config.NHDF, 0x01)" line48="        mpr121.configure(addr, mpr121.Config.NCLF, 0x10)" line49="        mpr121.configure(addr, mpr121.Config.FDLF, 0x20)" line50="" line51="        // Input filter for touched state" line52="        mpr121.configure(addr, mpr121.Config.NHDT, 0x01)" line53="        mpr121.configure(addr, mpr121.Config.NCLT, 0x10)" line54="        mpr121.configure(addr, mpr121.Config.FDLT, 0xFF)" line55="" line56="        // Unused proximity sensor filter" line57="        mpr121.configure(addr, mpr121.Config.MHDPROXR, 0x0F)" line58="        mpr121.configure(addr, mpr121.Config.NHDPROXR, 0x0F)" line59="        mpr121.configure(addr, mpr121.Config.NCLPROXR, 0x00)" line60="        mpr121.configure(addr, mpr121.Config.FDLPROXR, 0x00)" line61="        mpr121.configure(addr, mpr121.Config.MHDPROXF, 0x01)" line62="        mpr121.configure(addr, mpr121.Config.NHDPROXF, 0x01)" line63="        mpr121.configure(addr, mpr121.Config.NCLPROXF, 0xFF)" line64="        mpr121.configure(addr, mpr121.Config.FDLPROXF, 0xFF)" line65="        mpr121.configure(addr, mpr121.Config.NHDPROXT, 0x00)" line66="        mpr121.configure(addr, mpr121.Config.NCLPROXT, 0x00)" line67="        mpr121.configure(addr, mpr121.Config.FDLPROXT, 0x00)" line68="" line69="        // Debounce configuration (used primarily for interrupts)" line70="        mpr121.configure(addr, mpr121.Config.DTR, 0x11)" line71="" line72="        // Electrode clock frequency etc" line73="        mpr121.configure(addr, mpr121.Config.AFE1, 0xFF)" line74="        mpr121.configure(addr, mpr121.Config.AFE2, 0x30)" line75="" line76="        // Enable autoconfiguration / calibration" line77="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_0, 0x00)" line78="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_1, 0x00)" line79="" line80="        // Tuning parameters for the autocalibration algorithm" line81="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_USL, 0x00)" line82="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_LSL, 0x00)" line83="        mpr121.configure(addr, mpr121.Config.AUTO_CONFIG_TL, 0x00)" line84="" line85="        // Default sensitivity thresholds" line86="        mpr121.configureThresholds(addr, 60, 20)" line87="" line88="        // Restart capture" line89="        mpr121.start(" line90="            addr," line91="            mpr121.CalibrationLock.BaselineTrackingAndInitialize," line92="            mpr121.Proximity.DISABLED," line93="            mpr121.Touch.ELE_0_TO_11" line94="        )" line95="        control.inBackground(detectAndNotifyTouchEvents)" line96="    }" line97="" line98="    function detectAndNotifyTouchEvents() {" line99="        let previousTouchStatus = 0" line100="        " line101="        while (true) {" line102="            const touchStatus = mpr121.readTouchStatus(MPR121_ADDRESS)" line103="            touchController.lastTouchStatus = touchStatus" line104="" line105="            for (let touchSensorBit = 1; touchSensorBit &lt;= 2048; touchSensorBit &lt;&lt;= 1) {" line106="" line107="                // Raise event when touch starts" line108="                if ((touchSensorBit &amp; touchStatus) !== 0) {" line109="                    if (!((touchSensorBit &amp; previousTouchStatus) !== 0)) {" line110="                        control.raiseEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, touchSensorBit)" line111="                        touchController.lastEventValue = touchSensorBit" line112="                    }" line113="                }" line114="" line115="                // Raise event when touch ends" line116="                if ((touchSensorBit &amp; touchStatus) === 0) {" line117="                    if (!((touchSensorBit &amp; previousTouchStatus) === 0)) {" line118="                        control.raiseEvent(MPR121_TOUCH_SENSOR_RELEASED_ID, touchSensorBit)" line119="                        touchController.lastEventValue = touchSensorBit" line120="                    }" line121="                }" line122="            }" line123="" line124="            previousTouchStatus = touchStatus" line125="" line126="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line127="        }" line128="    }" line129="" line130="    /**" line131="     * Mache etwas, wenn ein spezieller Sensor berührt wird." line132="     * Dieses Touch-Ereignis wird direkt zu Beginn der Berührung ausgeführt." line133="     * @param sensor der Touchsensor der überwacht werden soll, z.B.: TouchSensor.T0" line134="     * @param handler body code der bei der Berührung des Sensors ausgeführt werden soll" line135="    */" line136="" line137="    //% blockId=mpr121_touch_on_touch_sensor_down" line138="    //% block=&quot;wenn Schalter | %sensor | gedrückt&quot;" line139="    //% sensor.fieldEditor=&quot;gridpicker&quot; sensor.fieldOptions.columns=3" line140="    //% sensor.fieldOptions.tooltips=&quot;false&quot;" line141="    //% weight=65" line142="    export function onTouchSensorTouched(sensor: TouchSensor, handler: () =&gt; void) {" line143="        initTouchController()" line144="        control.onEvent(MPR121_TOUCH_SENSOR_TOUCHED_ID, sensor, () =&gt; {" line145="            setupContextAndNotify(handler)" line146="        })" line147="    }" line148=" " line149="    function setupContextAndNotify(handler: () =&gt; void) {" line150="        touchController.lastEventValue = control.eventValue()" line151="        handler()" line152="    }" line153="" line154="    // Communication module for MPR121 capacitive touch sensor controller" line155="    // https://www.sparkfun.com/datasheets/Components/MPR121.pdf" line156="    export namespace mpr121 {" line157="" line158="        export enum CalibrationLock {" line159="            BaselineTrackingOn = 0b00," line160="            BaselineTrackingOff = 0b01," line161="            BaselineTrackingAndInitializeFirst5MSB = 0b10," line162="            BaselineTrackingAndInitialize = 0b11" line163="        }" line164="" line165="        export enum Proximity {" line166="            DISABLED = 0b00," line167="            ELE0_TO_1 = 0b01," line168="            ELE_0_TO_3 = 0b10," line169="            ELE_0_TO_11 = 0b11" line170="        }" line171="" line172="        export enum Touch {" line173="            DISABLED = 0b0000," line174="            ELE_0 = 0b0001," line175="            ELE_0_TO_1 = 0b0010," line176="            ELE_0_TO_2 = 0b0011," line177="            ELE_0_TO_3 = 0b0100," line178="            ELE_0_TO_4 = 0b0101," line179="            ELE_0_TO_5 = 0b0110," line180="            ELE_0_TO_6 = 0b0111," line181="            ELE_0_TO_7 = 0b1000," line182="            ELE_0_TO_8 = 0b1001," line183="            ELE_0_TO_9 = 0b1010," line184="            ELE_0_TO_10 = 0b1011," line185="            ELE_0_TO_11 = 0b1100" line186="        }" line187="" line188="        export enum Config {" line189="            MHDR = 0x2B," line190="            NHDR = 0x2C," line191="            NCLR = 0x2D," line192="            FDLR = 0x2E," line193="            MHDF = 0x2F," line194="            NHDF = 0x30," line195="            NCLF = 0x31," line196="            FDLF = 0x32," line197="            NHDT = 0x33," line198="            NCLT = 0x34," line199="            FDLT = 0x35," line200="            MHDPROXR = 0x36," line201="            NHDPROXR = 0x37," line202="            NCLPROXR = 0x38," line203="            FDLPROXR = 0x39," line204="            MHDPROXF = 0x3A," line205="            NHDPROXF = 0x3B," line206="            NCLPROXF = 0x3C," line207="            FDLPROXF = 0x3D," line208="            NHDPROXT = 0x3E," line209="            NCLPROXT = 0x3F," line210="            FDLPROXT = 0x40," line211="            E0TTH = 0x41," line212="            E0RTH = 0x42," line213="            E1TTH = 0x43," line214="            E1RTH = 0x44," line215="            E2TTH = 0x45," line216="            E2RTH = 0x46," line217="            E3TTH = 0x47," line218="            E3RTH = 0x48," line219="            E4TTH = 0x49," line220="            E4RTH = 0x4A," line221="            E5TTH = 0x4B," line222="            E5RTH = 0x4C," line223="            E6TTH = 0x4D," line224="            E6RTH = 0x4E," line225="            E7TTH = 0x4F," line226="            E7RTH = 0x50," line227="            E8TTH = 0x51," line228="            E8RTH = 0x52," line229="            E9TTH = 0x53," line230="            E9RTH = 0x54," line231="            E10TTH = 0x55," line232="            E10RTH = 0x56," line233="            E11TTH = 0x57," line234="            E11RTH = 0x58," line235="            E12TTH = 0x59," line236="            E12RTH = 0x5A," line237="            DTR = 0x5B," line238="            AFE1 = 0x5C," line239="            AFE2 = 0x5D," line240="            ECR = 0x5E," line241="            CDC0 = 0x5F," line242="            CDC1 = 0x60," line243="            CDC2 = 0x62," line244="            CDC4 = 0x63," line245="            CDC5 = 0x64," line246="            CDC6 = 0x65," line247="            CDC7 = 0x66," line248="            CDC8 = 0x67," line249="            CDC9 = 0x68," line250="            CDC10 = 0x69," line251="            CDC11 = 0x6A," line252="            CDC12 = 0x6B," line253="            CDT_0_1 = 0x6C," line254="            CDT_2_3 = 0x6D," line255="            CDT_4_5 = 0x6E," line256="            CDT_6_7 = 0x6F," line257="            CDT_8_9 = 0x70," line258="            CDT_10_11 = 0x71," line259="            CDT_12 = 0x72," line260="            GPIO_CTL0 = 0x73," line261="            GPIO_CTL1 = 0x74," line262="            GPIO_DIR = 0x76," line263="            GPIO_EN = 0x77," line264="            GPIO_SET = 0x78," line265="            GPIO_CLR = 0x79," line266="            GPIO_TOG = 0x7A," line267="            AUTO_CONFIG_0 = 0x7B," line268="            AUTO_CONFIG_1 = 0x7C," line269="            AUTO_CONFIG_USL = 0x7D," line270="            AUTO_CONFIG_LSL = 0x7E," line271="            AUTO_CONFIG_TL = 0x7F" line272="        }" line273="" line274="        let commandDataBuffer: Buffer" line275="        let commandBuffer: Buffer" line276="" line277="        function writeCommandData(address: number, command: number, data: number): void {" line278="            if (!commandDataBuffer) {" line279="                commandDataBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt16BE))" line280="            }" line281="            commandDataBuffer.setNumber(NumberFormat.UInt16BE, 0, (command &lt;&lt; 8) | data)" line282="            pins.i2cWriteBuffer(address, commandDataBuffer)" line283="        }" line284="" line285="        function writeCommand(address: number, command: number): void {" line286="            if (!commandBuffer) {" line287="                commandBuffer = pins.createBuffer(pins.sizeOf(NumberFormat.UInt8BE))" line288="            }" line289="            commandBuffer.setNumber(NumberFormat.UInt8BE, 0, command)" line290="            pins.i2cWriteBuffer(address, commandBuffer)" line291="        }" line292="" line293="        export function configure(address: number, register: Config, value: number): void {" line294="            writeCommandData(address, register, value)" line295="        }" line296="" line297="        export function configureThresholds(address: number, touch: number, release: number): void {" line298="            for (let i = 0; i &lt; 12; i++) {" line299="                configure(address, Config.E0TTH + i * 2, touch)" line300="                configure(address, Config.E0RTH + i * 2, release)" line301="            }" line302="        }" line303="" line304="        export function reset(address: number): void {" line305="            writeCommandData(address, 0x80, 0x63)" line306="            basic.pause(30)" line307="        }" line308="" line309="        export function stop(address: number): void {" line310="            writeCommandData(address, Config.ECR, 0x0)" line311="        }" line312="" line313="        export function start(address: number, cl: CalibrationLock, eleprox: Proximity, ele: Touch): void {" line314="            writeCommandData(address, Config.ECR, (cl &lt;&lt; 6) | (eleprox &lt;&lt; 4) | ele)" line315="        }" line316="" line317="        export function readTouchStatus(address: number): number {" line318="            writeCommand(address, 0x0)" line319="            return pins.i2cReadNumber(address, NumberFormat.UInt16LE)" line320="        }" line321="    }" line322="" line323="    /**" line324="    * Code for the presence controller." line325="    */" line326="" line327="    interface PresenceDetector {" line328="        lastPresenceDetection: boolean" line329="    }" line330="" line331="    let presenceDetector: PresenceDetector" line332="    const PRESENCE_DETECTED_ID = 2147" line333="" line334="    /**" line335="     * Initialize the presence controller." line336="     */" line337="" line338="    //% blockId=&quot;presence_init&quot; block=&quot;initialisiere Präsenz-Sensor&quot;" line339="    //% weight=70" line340="    function initPresenceDetector(): void {" line341="" line342="        if (!!presenceDetector) {" line343="            return" line344="        }" line345="" line346="        presenceDetector = {" line347="            lastPresenceDetection: false" line348="        }" line349="" line350="        control.inBackground(detectAndNotifyPresenceDetector)" line351="    }" line352="" line353="    function detectAndNotifyPresenceDetector() {" line354="        let previousPresenceStatus = false;" line355="" line356="        while (true) {" line357="            if (previousPresenceStatus == false &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 0) {" line358="                control.raiseEvent(PRESENCE_DETECTED_ID, 0);" line359="                previousPresenceStatus = true;" line360="            }" line361="            if (previousPresenceStatus == true &amp;&amp; pins.digitalReadPin(DigitalPin.C9) == 1) {" line362="                previousPresenceStatus = false;" line363="            }" line364="" line365="            basic.pause(TOUCH_STATUS_PAUSE_BETWEEN_READ)" line366="        }" line367="" line368="" line369="    }" line370="" line371="    //% blockId=smarthome_presence_detected" line372="    //% block=&quot;wenn Präsenz gemeldet&quot;" line373="    //% weight=65" line374="    export function onPresenceDetected(handler: () =&gt; void) {" line375="        initPresenceDetector();" line376="        control.onEvent(PRESENCE_DETECTED_ID, EventBusValue.MICROBIT_EVT_ANY, () =&gt; {" line377="            handler();" line378="        })" line379="    }" line380="}" numlines="381"></mutation><next><block type="device_show_leds" id="J`H[zNV)XAku/*VL7T1+"><field name="LEDS">`
        . . . . . 
        . . . . . 
        . . # . . 
        . . . . . 
        . . . . .
        `</field></block></next></block></next></block></statement></block><block type="mpr121_touch_on_touch_sensor_down" id="edCI(u9breS{QnN9@IBt" x="367" y="15935"><field name="sensor">TouchSensor.S0</field></block><block type="device_forever" id="-N1WCTqLnS9eZ6ZIt,#K" x="614" y="18137"></block><block type="device_button_selected_event" id="8sdEKLE$@WYvTxJf|+g7" x="530" y="19197"><field name="NAME">Button.A</field><value name="eventType"><shadow type="control_button_event_click" id="5g!0.RZU.E0Yev=~j%m7"></shadow></value><statement name="HANDLER"><block type="basic_show_icon" id="VT.;!f1;$%AbAw9/6]{/"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.No</field></block></statement></block><block type="device_pin_custom_event" id="c6tk2q^)-oIBEQl:7y2!" x="336" y="19377"><field name="name">TouchPin.P1</field><value name="eventType"><shadow type="control_button_event_down" id=")4TV5`TAqnPfzY;Bf47n"></shadow></value><statement name="HANDLER"><block type="device_show_leds" id="I0!0`g!T04uD(^tdbN*$"><field name="LEDS">`
        . . . . . 
        . . . . . 
        # # # . . 
        . . . . . 
        . . . . .
        `</field></block></statement></block><block type="smarthome_presence_detected" id="uAOM_ga/k[W5%hz4]Ohf" x="135" y="19883"><statement name="HANDLER"><block type="basic_show_icon" id="RCIZdHZl|gjhe{@W|41y"><mutation xmlns="http://www.w3.org/1999/xhtml" _expanded="0" _input_init="true"></mutation><field name="i">IconNames.Butterfly</field><next><block type="device_play_note" id=";;;kR)%@Ee=W}p_?x;]["><value name="note"><shadow type="device_note" id="JK%j.mNJLnTsLBL$NLDP"><field name="name">262</field></shadow></value><value name="duration"><shadow type="device_beat" id="nz?xM,iuQ/A4C]-vt^[T"><field name="fraction">BeatFraction.Whole</field></shadow></value></block></next></block></statement></block></xml>